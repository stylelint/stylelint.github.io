{"head":{"description":"Writing plugins Plugins are rules and sets of rules built by the community. We recommend familiarising yourself and adhering to stylelint'sâ€¦","title":"Writing plugins"},"body":"<h1 id=\"writing-plugins\"><a href=\"#writing-plugins\" class=\"phenomic-HeadingAnchor\">#</a>Writing plugins</h1>\n<p>Plugins are rules and sets of rules built by the community.</p>\n<p>We recommend familiarising yourself and adhering to stylelint's <a href=\"../rules/\">conventions for writing rules</a>, including those for names, options, messages, tests and docs.</p>\n<h2 id=\"the-anatomy-of-a-plugin\"><a href=\"#the-anatomy-of-a-plugin\" class=\"phenomic-HeadingAnchor\">#</a>The anatomy of a plugin</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Abbreviated example</span>\n<span class=\"hljs-keyword\">var</span> stylelint = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"stylelint\"</span>)\n\n<span class=\"hljs-keyword\">var</span> ruleName = <span class=\"hljs-string\">\"plugin/foo-bar\"</span>\n<span class=\"hljs-keyword\">var</span> messages =  stylelint.utils.ruleMessages(ruleName, {\n  <span class=\"hljs-attr\">expected</span>: <span class=\"hljs-string\">\"Expected ...\"</span>,\n})\n\n<span class=\"hljs-built_in\">module</span>.exports = stylelint.createPlugin(ruleName, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">primaryOption, secondaryOptionObject</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">postcssRoot, postcssResult</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> validOptions = stylelint.utils.validateOptions(postcssResult, ruleName, { .. })\n    <span class=\"hljs-keyword\">if</span> (!validOptions) { <span class=\"hljs-keyword\">return</span> }\n    <span class=\"hljs-comment\">// ... some logic ...</span>\n    stylelint.utils.report({ .. })\n  }\n})\n\n<span class=\"hljs-built_in\">module</span>.exports.ruleName = ruleName\n<span class=\"hljs-built_in\">module</span>.exports.messages = messages</code></pre>\n<p>Your plugin's rule name must be namespaced, e.g. <code>your-namespace/your-rule-name</code>. If your plugin provides only a single rule or you can't think of a good namespace, you can simply use <code>plugin/my-rule</code>. This namespace ensures that plugin rules will never clash with core rules. <em>Make sure you document your plugin's rule name (and namespace) for users, because they will need to use it in their config.</em></p>\n<p><code>stylelint.createPlugin(ruleName, ruleFunction)</code> ensures that your plugin will be setup properly alongside other rules.</p>\n<p>In order for your plugin rule to work with the <a href=\"../../user-guide/configuration/#rules\">standard configuration format</a>, <code>ruleFunction</code> should accept 2 arguments: the primary option and, optionally, an secondary options object.</p>\n<p><code>ruleFunction</code> should return a function that is essentially a little <a href=\"https://github.com/postcss/postcss/blob/master/docs/writing-a-plugin.md\">PostCSS plugin</a>: it takes 2 arguments: the PostCSS Root (the parsed AST), and the PostCSS LazyResult. You'll have to <a href=\"https://github.com/postcss/postcss/blob/master/docs/api.md\">learn about the PostCSS API</a>.</p>\n<h2 id=\"stylelintutils\"><a href=\"#stylelintutils\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils</code></h2>\n<p>stylelint exposes some utilities that are useful. <em>For details about the APIs of these functions, please look at comments in the source code and examples in the standard rules.</em></p>\n<h3 id=\"stylelintutilsreport\"><a href=\"#stylelintutilsreport\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils.report</code></h3>\n<p>Adds warnings from your plugin to the list of warnings that stylelint will report to the user.</p>\n<p><em>Do not use PostCSS's <code>node.warn()</code> method directly.</em> When you use <code>stylelint.utils.report</code>, your plugin will respect disabled ranges and other possible future features of stylelint, providing a better user-experience, one that better fits the standard rules.</p>\n<h3 id=\"stylelintutilsrulemessages\"><a href=\"#stylelintutilsrulemessages\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils.ruleMessages</code></h3>\n<p>Tailors your messages to the format of standard stylelint rules.</p>\n<h3 id=\"stylelintutilsvalidateoptions\"><a href=\"#stylelintutilsvalidateoptions\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils.validateOptions</code></h3>\n<p>Validates the options for your rule.</p>\n<h3 id=\"stylelintutilscheckagainstrule\"><a href=\"#stylelintutilscheckagainstrule\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils.checkAgainstRule</code></h3>\n<p>Checks CSS against a standard stylelint rule <em>within your own rule</em>. This function provides power and flexibility for plugins authors who wish to modify, constrain, or extend the functionality of existing stylelint rules.</p>\n<p>Accepts an options object and a callback that is invoked with warnings from the specified rule. The options are:</p>\n<ul>\n<li><code>ruleName</code>: The name of the rule you are invoking.</li>\n<li><code>ruleSettings</code>: Settings for the rule you are invoking, formatting in the same way they would be in a <code>.stylelintrc</code> configuration object.</li>\n<li><code>root</code>: The root node to run this rule against.</li>\n</ul>\n<p>Use the warning to create a <em>new</em> warning <em>from your plugin rule</em> that you report with <code>stylelint.utils.report</code>.</p>\n<p>For example, imagine you want to create a plugin that runs <code>at-rule-no-unknown</code> with a built-in list of exceptions for at-rules provided by your preprocessor-of-choice:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> allowableAtRules = [..]\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myPluginRule</span>(<span class=\"hljs-params\">primaryOption, secondaryOptions</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">root, result</span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> defaultedOptions = <span class=\"hljs-built_in\">Object</span>.assign({}, secondaryOptions, {\n      <span class=\"hljs-attr\">ignoreAtRules</span>: allowableAtRules.concat(options.ignoreAtRules || []),\n    })\n\n    stylelint.utils.checkAgainstRule({\n      <span class=\"hljs-attr\">ruleName</span>: <span class=\"hljs-string\">'at-rule-no-unknown'</span>,\n      <span class=\"hljs-attr\">ruleSettings</span>: [primaryOption, defaultedOptions],\n      <span class=\"hljs-attr\">root</span>: root\n    }, (warning) => {\n      stylelint.utils.report({\n        <span class=\"hljs-attr\">message</span>: myMessage,   \n        <span class=\"hljs-attr\">ruleName</span>: myRuleName,     \n        <span class=\"hljs-attr\">result</span>: result,        \n        <span class=\"hljs-attr\">node</span>: warning.node,\n        <span class=\"hljs-attr\">line</span>: warning.line,\n        <span class=\"hljs-attr\">column</span>: warning.column,\n      })\n    })\n  }\n}</code></pre>\n<h2 id=\"stylelintrules\"><a href=\"#stylelintrules\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.rules</code></h2>\n<p>All of the rule functions are available at <code>stylelint.rules</code>. This allows you to build on top of existing rules for your particular needs.</p>\n<p>A typical use-case is to build in more complex conditionals that the rule's options allow for. For example, maybe your codebase uses special comment directives to customize rule options for specific stylesheets. You could build a plugin that checks those directives and then runs the appropriate rules with the right options (or doesn't run them at all).</p>\n<p>All rules share a common signature. They are a function that accepts two arguments: a primary option and a secondary options object. And that functions returns a function that has the signature of a PostCSS plugin, expecting a PostCSS root and result as its arguments.</p>\n<p>Here's a simple example of a plugin that runs <code>color-hex-case</code> only if there is a special directive <code>@@check-color-hex-case</code> somewhere in the stylesheet:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> stylelint.createPlugin(ruleName, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">expectation</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> runColorHexCase = stylelint.rules[<span class=\"hljs-string\">\"color-hex-case\"</span>](expectation)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">root, result</span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (root.toString().indexOf(<span class=\"hljs-string\">\"@@check-color-hex-case\"</span>) === <span class=\"hljs-number\">-1</span>) <span class=\"hljs-keyword\">return</span>\n    runColorHexCase(root, result)\n  }\n})</code></pre>\n<h2 id=\"allow-primary-option-arrays\"><a href=\"#allow-primary-option-arrays\" class=\"phenomic-HeadingAnchor\">#</a>Allow primary option arrays</h2>\n<p>If your plugin can accept an array as its primary option, you must designate this by setting the property <code>primaryOptionArray = true</code> on your rule function. For more information, check out the <a href=\"../rules/#primary\">\"Working on rules\"</a> doc.</p>\n<h2 id=\"external-helper-modules\"><a href=\"#external-helper-modules\" class=\"phenomic-HeadingAnchor\">#</a>External helper modules</h2>\n<p>In addition to the standard parsers mentioned in the <a href=\"../rules/\">\"Working on rules\"</a> doc, there are other external modules used within stylelint that we recommend using. These include:</p>\n<ul>\n<li><a href=\"https://github.com/getify/normalize-selector\">normalize-selector</a>: Normalize CSS selectors.</li>\n<li><a href=\"https://github.com/davidtheclark/postcss-resolve-nested-selector\">postcss-resolve-nested-selector</a>: Given a (nested) selector in a PostCSS AST, return an array of resolved selectors.</li>\n<li><a href=\"https://github.com/davidtheclark/style-search\">style-search</a>: Search CSS (and CSS-like) strings, with sensitivity to whether matches occur inside strings, comments, and functions.</li>\n</ul>\n<p>Have a look through <a href=\"https://github.com/stylelint/stylelint/tree/master/lib/utils\">stylelint's internal utils</a> and if you come across one that you need in your plugin, then please consider helping us extract it out into a external module.</p>\n<h2 id=\"testing-plugins\"><a href=\"#testing-plugins\" class=\"phenomic-HeadingAnchor\">#</a>Testing plugins</h2>\n<p>For testing your plugin, you might consider using the same rule-testing function that stylelint uses internally: <a href=\"https://github.com/stylelint/stylelint-test-rule-tape\"><code>stylelint-test-rule-tape</code></a>.</p>\n<h2 id=\"plugin-packs\"><a href=\"#plugin-packs\" class=\"phenomic-HeadingAnchor\">#</a>Plugin packs</h2>\n<p>To make a single module provide multiple rules, simply export an array of plugin objects (rather than a single object).</p>\n<h2 id=\"sharing-plugins-and-plugin-packs\"><a href=\"#sharing-plugins-and-plugin-packs\" class=\"phenomic-HeadingAnchor\">#</a>Sharing plugins and plugin packs</h2>\n<ul>\n<li>Use the <code>stylelint-plugin</code> keyword within your <code>package.json</code>.</li>\n<li>Once your plugin is published, please send us a Pull Request to add your plugin to <a href=\"../../user-guide/plugins/\">the list</a>.</li>\n</ul>\n","__filename":"developer-guide/plugins.md","__url":"/developer-guide/plugins/","__resourceUrl":"/developer-guide/plugins/index.html","__dataUrl":"/developer-guide/plugins/index.html.d6cb4ebca49a169e257cefe324a4aa65.json"}