{"head":{"title":"Writing plugins"},"body":"<h1 id=\"writing-plugins\"><a class=\"markdownIt-Anchor\" href=\"#writing-plugins\">#</a> Writing plugins</h1>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// Abbreviated example:</span>\n\n<span class=\"hljs-keyword\">var</span> stylelint = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"stylelint\"</span>)\n\n<span class=\"hljs-keyword\">var</span> myPluginRuleName = <span class=\"hljs-string\">\"foobar\"</span>\n<span class=\"hljs-keyword\">var</span> myPluginRule = stylelint.createPlugin(myPluginRuleName, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">expectationKeyword, optionsObject</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">postcssRoot, postcssResult</span>) </span>{\n    <span class=\"hljs-comment\">// ... some logic ...</span>\n    stylelint.utils.report({ .. })\n  }\n}\n</code></pre>\n<p><code>stylelint.createPlugin(ruleName, ruleFunction)</code> ensures that your plugin will be setup properly alongside other rules.\n<em>Make sure you document your plugin’s rule name for users, because they will need to use it in their config.</em></p>\n<p>In order for your plugin rule to work with the standard configuration format, (e.g. <code>[&quot;tab&quot;, { hierarchicalSelectors: true }]</code>), <code>ruleFunction</code> should accept 2 arguments: the expectation keyword (e.g. <code>&quot;tab&quot;</code>) and, optionally, an options object (e.g. <code>{ hierarchicalSelectors: true }</code>).</p>\n<p><code>ruleFunction</code> should return a function that is essentially a little PostCSS plugin: it takes 2 arguments: the PostCSS Root (the parsed AST), and the PostCSS LazyResult.\nYou’ll have to <a href=\"https://github.com/postcss/postcss/blob/master/api\">learn about the PostCSS API</a>.</p>\n<h2 id=\"stylelint-utils\"><a class=\"markdownIt-Anchor\" href=\"#stylelint-utils\">#</a> <code>stylelint.utils</code></h2>\n<p>A few of stylelint’s internal utilities are exposed publicly in <code>stylelint.utils</code>, to help you write plugin rules.\nFor details about the APIs of these functions, please look at comments in the source code and examples in the standard rules.</p>\n<ul>\n<li><code>report</code>: Report your linting warnings. <em>You’ll want to use this: do not use <code>node.warn()</code> directly.</em> If you use <code>report</code>,\nyour plugin will respect disabled ranges and other possible future features of stylelint, so it will fit in better with the standard rules.</li>\n<li><code>ruleMessages</code>: Tailor your messages to look like the messages of other stylelint rules. Currently, this means that the name of the rule is appended, in parentheses, to the end of the message.</li>\n<li><code>styleSearch</code>: Search within CSS strings, and for every match found invoke a callback, passing a match object with details about the match. <code>styleSearch</code> ignores CSS strings (e.g. <code>content: &quot;foo&quot;;</code>) and by default ignores comments. It can also be restricted to substrings within or outside of CSS functional notation.</li>\n<li><code>validateOptions</code>: Help your user’s out by checking that the options they’ve submitted are valid.</li>\n</ul>\n<h2 id=\"stylelint-rules\"><a class=\"markdownIt-Anchor\" href=\"#stylelint-rules\">#</a> <code>stylelint.rules</code></h2>\n<p>All of the rule functions are available at <code>stylelint.rules</code>. This allows you to build on top of existing rules for your particular needs.</p>\n<p>A typical use-case is to build in more complex conditionals that the rule’s options allow for. For example, maybe your codebase uses special comment directives to customize rule options for specific stylesheets. You could build a plugin that checks those directives and then runs the appropriate rules with the right options (or doesn’t run them at all).</p>\n<p>All rules share a common signature. They are a function that accepts two arguments: a primary option and a secondary options object. And that functions returns a function that has the signature of a PostCSS plugin, expecting a PostCSS root and result as its arguments.</p>\n<p>Here’s a simple example of a plugin that runs <code>color-hex-case</code> only if there is a special directive <code>@@check-color-hex-case</code> somewhere in the stylesheet:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> stylelint.createPlugin(ruleName, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">expectation</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> runColorHexCase = stylelint.rules[<span class=\"hljs-string\">\"color-hex-case\"</span>](expectation)\n  <span class=\"hljs-keyword\">return</span> (root, result) =&gt; {\n    <span class=\"hljs-keyword\">if</span> (root.toString().indexOf(<span class=\"hljs-string\">\"@@check-color-hex-case\"</span>) === <span class=\"hljs-number\">-1</span>) <span class=\"hljs-keyword\">return</span>\n    runColorHexCase(root, result)\n  }\n})\n</code></pre>\n<h2 id=\"testing-plugins\"><a class=\"markdownIt-Anchor\" href=\"#testing-plugins\">#</a> Testing plugins</h2>\n<p>For testing your plugin, you might consider using the same rule-testing function that stylelint uses internally: <a href=\"https://github.com/stylelint/stylelint-rule-tester\"><code>stylelint-rule-tester</code></a>.</p>\n","rawBody":"\n# Writing plugins\n\n```js\n// Abbreviated example:\n\nvar stylelint = require(\"stylelint\")\n\nvar myPluginRuleName = \"foobar\"\nvar myPluginRule = stylelint.createPlugin(myPluginRuleName, function(expectationKeyword, optionsObject) {\n  return function(postcssRoot, postcssResult) {\n    // ... some logic ...\n    stylelint.utils.report({ .. })\n  }\n}\n```\n\n`stylelint.createPlugin(ruleName, ruleFunction)` ensures that your plugin will be setup properly alongside other rules.\n*Make sure you document your plugin's rule name for users, because they will need to use it in their config.*\n\nIn order for your plugin rule to work with the standard configuration format, (e.g. `[\"tab\", { hierarchicalSelectors: true }]`), `ruleFunction` should accept 2 arguments: the expectation keyword (e.g. `\"tab\"`) and, optionally, an options object (e.g. `{ hierarchicalSelectors: true }`).\n\n`ruleFunction` should return a function that is essentially a little PostCSS plugin: it takes 2 arguments: the PostCSS Root (the parsed AST), and the PostCSS LazyResult.\nYou'll have to [learn about the PostCSS API](https://github.com/postcss/postcss/blob/master/api).\n\n## `stylelint.utils`\n\nA few of stylelint's internal utilities are exposed publicly in `stylelint.utils`, to help you write plugin rules.\nFor details about the APIs of these functions, please look at comments in the source code and examples in the standard rules.\n\n- `report`: Report your linting warnings. *You'll want to use this: do not use `node.warn()` directly.* If you use `report`,\nyour plugin will respect disabled ranges and other possible future features of stylelint, so it will fit in better with the standard rules.\n- `ruleMessages`: Tailor your messages to look like the messages of other stylelint rules. Currently, this means that the name of the rule is appended, in parentheses, to the end of the message.\n- `styleSearch`: Search within CSS strings, and for every match found invoke a callback, passing a match object with details about the match. `styleSearch` ignores CSS strings (e.g. `content: \"foo\";`) and by default ignores comments. It can also be restricted to substrings within or outside of CSS functional notation.\n- `validateOptions`: Help your user's out by checking that the options they've submitted are valid.\n\n## `stylelint.rules`\n\nAll of the rule functions are available at `stylelint.rules`. This allows you to build on top of existing rules for your particular needs.\n\nA typical use-case is to build in more complex conditionals that the rule's options allow for. For example, maybe your codebase uses special comment directives to customize rule options for specific stylesheets. You could build a plugin that checks those directives and then runs the appropriate rules with the right options (or doesn't run them at all).\n\nAll rules share a common signature. They are a function that accepts two arguments: a primary option and a secondary options object. And that functions returns a function that has the signature of a PostCSS plugin, expecting a PostCSS root and result as its arguments.\n\nHere's a simple example of a plugin that runs `color-hex-case` only if there is a special directive `@@check-color-hex-case` somewhere in the stylesheet:\n\n```js\nexport default stylelint.createPlugin(ruleName, function (expectation) {\n  const runColorHexCase = stylelint.rules[\"color-hex-case\"](expectation)\n  return (root, result) => {\n    if (root.toString().indexOf(\"@@check-color-hex-case\") === -1) return\n    runColorHexCase(root, result)\n  }\n})\n```\n\n## Testing plugins\n\nFor testing your plugin, you might consider using the same rule-testing function that stylelint uses internally: [`stylelint-rule-tester`](https://github.com/stylelint/stylelint-rule-tester).\n","raw":"---\ntitle: Writing plugins\n---\n\n# Writing plugins\n\n```js\n// Abbreviated example:\n\nvar stylelint = require(\"stylelint\")\n\nvar myPluginRuleName = \"foobar\"\nvar myPluginRule = stylelint.createPlugin(myPluginRuleName, function(expectationKeyword, optionsObject) {\n  return function(postcssRoot, postcssResult) {\n    // ... some logic ...\n    stylelint.utils.report({ .. })\n  }\n}\n```\n\n`stylelint.createPlugin(ruleName, ruleFunction)` ensures that your plugin will be setup properly alongside other rules.\n*Make sure you document your plugin's rule name for users, because they will need to use it in their config.*\n\nIn order for your plugin rule to work with the standard configuration format, (e.g. `[\"tab\", { hierarchicalSelectors: true }]`), `ruleFunction` should accept 2 arguments: the expectation keyword (e.g. `\"tab\"`) and, optionally, an options object (e.g. `{ hierarchicalSelectors: true }`).\n\n`ruleFunction` should return a function that is essentially a little PostCSS plugin: it takes 2 arguments: the PostCSS Root (the parsed AST), and the PostCSS LazyResult.\nYou'll have to [learn about the PostCSS API](https://github.com/postcss/postcss/blob/master/api).\n\n## `stylelint.utils`\n\nA few of stylelint's internal utilities are exposed publicly in `stylelint.utils`, to help you write plugin rules.\nFor details about the APIs of these functions, please look at comments in the source code and examples in the standard rules.\n\n- `report`: Report your linting warnings. *You'll want to use this: do not use `node.warn()` directly.* If you use `report`,\nyour plugin will respect disabled ranges and other possible future features of stylelint, so it will fit in better with the standard rules.\n- `ruleMessages`: Tailor your messages to look like the messages of other stylelint rules. Currently, this means that the name of the rule is appended, in parentheses, to the end of the message.\n- `styleSearch`: Search within CSS strings, and for every match found invoke a callback, passing a match object with details about the match. `styleSearch` ignores CSS strings (e.g. `content: \"foo\";`) and by default ignores comments. It can also be restricted to substrings within or outside of CSS functional notation.\n- `validateOptions`: Help your user's out by checking that the options they've submitted are valid.\n\n## `stylelint.rules`\n\nAll of the rule functions are available at `stylelint.rules`. This allows you to build on top of existing rules for your particular needs.\n\nA typical use-case is to build in more complex conditionals that the rule's options allow for. For example, maybe your codebase uses special comment directives to customize rule options for specific stylesheets. You could build a plugin that checks those directives and then runs the appropriate rules with the right options (or doesn't run them at all).\n\nAll rules share a common signature. They are a function that accepts two arguments: a primary option and a secondary options object. And that functions returns a function that has the signature of a PostCSS plugin, expecting a PostCSS root and result as its arguments.\n\nHere's a simple example of a plugin that runs `color-hex-case` only if there is a special directive `@@check-color-hex-case` somewhere in the stylesheet:\n\n```js\nexport default stylelint.createPlugin(ruleName, function (expectation) {\n  const runColorHexCase = stylelint.rules[\"color-hex-case\"](expectation)\n  return (root, result) => {\n    if (root.toString().indexOf(\"@@check-color-hex-case\") === -1) return\n    runColorHexCase(root, result)\n  }\n})\n```\n\n## Testing plugins\n\nFor testing your plugin, you might consider using the same rule-testing function that stylelint uses internally: [`stylelint-rule-tester`](https://github.com/stylelint/stylelint-rule-tester).\n","__filename":"developer-guide/plugins.md","__url":"/developer-guide/plugins/"}