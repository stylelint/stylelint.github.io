{"head":{"title":"no-descending-specificity","description":"no-descending-specificity\n\nDisallow selectors of lower specificity from coming after overriding selectors of higher specificity.\n\nSource…"},"body":"<h1 id=\"no-descending-specificity\"><a href=\"#no-descending-specificity\" class=\"phenomic-HeadingAnchor\">#</a>no-descending-specificity</h1>\n<p>Disallow selectors of lower specificity from coming after overriding selectors of higher specificity.</p>\n<pre><code class=\"hljs language-css\">    <span class=\"hljs-selector-id\">#container</span> <span class=\"hljs-selector-tag\">a</span> { <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">10px</span>; } <span class=\"hljs-selector-tag\">a</span> { <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>; }\n<span class=\"hljs-comment\">/** ↑                           ↑\n * The order of these selectors represents descending specificity */</span></code></pre>\n<p>Source order is important in CSS, and when two selectors have the <em>same</em> specificity, the one that occurs <em>last</em> will take priority. However, the situation is different when one of the selectors has a <em>higher</em> specificity. In that case, source order does <em>not</em> matter: the selector with higher specificity will win out even if it comes first.</p>\n<p>The clashes of these two mechanisms for prioritization, source order and specificity, can cause some confusion when reading stylesheets. If a selector with higher specificity comes <em>before</em> the selector it overrides, we have to think harder to understand it, because it violates the source order expectation. <strong>Stylesheets are most legible when overriding selectors always come <em>after</em> the selectors they override.</strong> That way both mechanisms, source order and specificity, work together nicely.</p>\n<p>This rule enforces that practice <em>as best it can</em>. (It cannot catch every actual overriding selector (because it does not know the DOM structure, for one), but it can catch certain common mistakes.)</p>\n<p>Here&#x27;s how it works: <strong>This rule looks at the last <em>compound selector</em> in every full selector, and then compares it with other selectors in the stylesheet that end in the same way.</strong></p>\n<p>So <code>.foo .bar</code> (whose last compound selector is <code>.bar</code>) will be compared to <code>.bar</code> and <code>#baz .bar</code>, but not to <code>#baz .foo</code> or <code>.bar .foo</code>.</p>\n<p>And <code>a &gt; li#wag.pit</code> (whose last compound selector is <code>li#wag.pit</code>) will be compared to <code>div li#wag.pit</code> and <code>a &gt; b &gt; li + li#wag.pit</code>, but not to <code>li</code>, or <code>li #wag</code>, etc.</p>\n<p>This rule only compares rules that are within the same media context. So <code>a {} @media print { #baz a {} }</code> is fine.</p>\n<p>This rule resolves nested selectors before calculating the specificity of the selectors.</p>\n<p>The following patterns are considered warnings:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">b</span> <span class=\"hljs-selector-tag\">a</span> {}\n<span class=\"hljs-selector-tag\">a</span> {}</code></pre>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">a</span> + <span class=\"hljs-selector-tag\">a</span> {}\n<span class=\"hljs-selector-tag\">a</span> {}</code></pre>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">b</span> &gt; <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[foo]</span> {}\n<span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[foo]</span> {}</code></pre>\n<pre><code class=\"hljs language-css\">a {\n  &amp; &gt; b {}\n}\nb {}</code></pre>\n<pre><code class=\"hljs language-css\">@<span class=\"hljs-keyword\">media</span> print {\n  <span class=\"hljs-selector-id\">#c</span> <span class=\"hljs-selector-tag\">a</span> {}\n  <span class=\"hljs-selector-tag\">a</span> {}\n}</code></pre>\n<p>The following patterns are <em>not</em> considered warnings:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">a</span> {}\n<span class=\"hljs-selector-tag\">b</span> <span class=\"hljs-selector-tag\">a</span> {}</code></pre>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">a</span> {}\n<span class=\"hljs-selector-tag\">a</span> + <span class=\"hljs-selector-tag\">a</span> {}</code></pre>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[foo]</span> {}\n<span class=\"hljs-selector-tag\">b</span> &gt; <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[foo]</span> {}</code></pre>\n<pre><code class=\"hljs language-css\">b {}\na {\n  &amp; &gt; b {}\n}</code></pre>\n<pre><code class=\"hljs language-css\">@<span class=\"hljs-keyword\">media</span> print {\n  <span class=\"hljs-selector-tag\">a</span> {}\n  <span class=\"hljs-selector-id\">#c</span> <span class=\"hljs-selector-tag\">a</span> {}\n}</code></pre>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">a</span> {}\n@<span class=\"hljs-keyword\">media</span> print {\n  <span class=\"hljs-selector-id\">#baz</span> <span class=\"hljs-selector-tag\">a</span> {}\n}</code></pre>\n","rawBody":"\n# no-descending-specificity\n\nDisallow selectors of lower specificity from coming after overriding selectors of higher specificity.\n\n```css\n    #container a { top: 10px; } a { top: 0; }\n/** ↑                           ↑\n * The order of these selectors represents descending specificity */\n```\n\nSource order is important in CSS, and when two selectors have the *same* specificity, the one that occurs *last* will take priority. However, the situation is different when one of the selectors has a *higher* specificity. In that case, source order does *not* matter: the selector with higher specificity will win out even if it comes first.\n\nThe clashes of these two mechanisms for prioritization, source order and specificity, can cause some confusion when reading stylesheets. If a selector with higher specificity comes *before* the selector it overrides, we have to think harder to understand it, because it violates the source order expectation. **Stylesheets are most legible when overriding selectors always come *after* the selectors they override.** That way both mechanisms, source order and specificity, work together nicely.\n\nThis rule enforces that practice *as best it can*. (It cannot catch every actual overriding selector (because it does not know the DOM structure, for one), but it can catch certain common mistakes.)\n\nHere's how it works: **This rule looks at the last *compound selector* in every full selector, and then compares it with other selectors in the stylesheet that end in the same way.**\n\nSo `.foo .bar` (whose last compound selector is `.bar`) will be compared to `.bar` and `#baz .bar`, but not to `#baz .foo` or `.bar .foo`.\n\nAnd `a > li#wag.pit` (whose last compound selector is `li#wag.pit`) will be compared to `div li#wag.pit` and `a > b > li + li#wag.pit`, but not to `li`, or `li #wag`, etc.\n\nThis rule only compares rules that are within the same media context. So `a {} @media print { #baz a {} }` is fine.\n\nThis rule resolves nested selectors before calculating the specificity of the selectors.\n\nThe following patterns are considered warnings:\n\n```css\nb a {}\na {}\n```\n\n```css\na + a {}\na {}\n```\n\n```css\nb > a[foo] {}\na[foo] {}\n```\n\n```css\na {\n  & > b {}\n}\nb {}\n```\n\n```css\n@media print {\n  #c a {}\n  a {}\n}\n```\n\nThe following patterns are *not* considered warnings:\n\n```css\na {}\nb a {}\n```\n\n```css\na {}\na + a {}\n```\n\n```css\na[foo] {}\nb > a[foo] {}\n```\n\n```css\nb {}\na {\n  & > b {}\n}\n```\n\n```css\n@media print {\n  a {}\n  #c a {}\n}\n```\n\n```css\na {}\n@media print {\n  #baz a {}\n}\n```\n","raw":"---\ntitle: no-descending-specificity\n---\n\n# no-descending-specificity\n\nDisallow selectors of lower specificity from coming after overriding selectors of higher specificity.\n\n```css\n    #container a { top: 10px; } a { top: 0; }\n/** ↑                           ↑\n * The order of these selectors represents descending specificity */\n```\n\nSource order is important in CSS, and when two selectors have the *same* specificity, the one that occurs *last* will take priority. However, the situation is different when one of the selectors has a *higher* specificity. In that case, source order does *not* matter: the selector with higher specificity will win out even if it comes first.\n\nThe clashes of these two mechanisms for prioritization, source order and specificity, can cause some confusion when reading stylesheets. If a selector with higher specificity comes *before* the selector it overrides, we have to think harder to understand it, because it violates the source order expectation. **Stylesheets are most legible when overriding selectors always come *after* the selectors they override.** That way both mechanisms, source order and specificity, work together nicely.\n\nThis rule enforces that practice *as best it can*. (It cannot catch every actual overriding selector (because it does not know the DOM structure, for one), but it can catch certain common mistakes.)\n\nHere's how it works: **This rule looks at the last *compound selector* in every full selector, and then compares it with other selectors in the stylesheet that end in the same way.**\n\nSo `.foo .bar` (whose last compound selector is `.bar`) will be compared to `.bar` and `#baz .bar`, but not to `#baz .foo` or `.bar .foo`.\n\nAnd `a > li#wag.pit` (whose last compound selector is `li#wag.pit`) will be compared to `div li#wag.pit` and `a > b > li + li#wag.pit`, but not to `li`, or `li #wag`, etc.\n\nThis rule only compares rules that are within the same media context. So `a {} @media print { #baz a {} }` is fine.\n\nThis rule resolves nested selectors before calculating the specificity of the selectors.\n\nThe following patterns are considered warnings:\n\n```css\nb a {}\na {}\n```\n\n```css\na + a {}\na {}\n```\n\n```css\nb > a[foo] {}\na[foo] {}\n```\n\n```css\na {\n  & > b {}\n}\nb {}\n```\n\n```css\n@media print {\n  #c a {}\n  a {}\n}\n```\n\nThe following patterns are *not* considered warnings:\n\n```css\na {}\nb a {}\n```\n\n```css\na {}\na + a {}\n```\n\n```css\na[foo] {}\nb > a[foo] {}\n```\n\n```css\nb {}\na {\n  & > b {}\n}\n```\n\n```css\n@media print {\n  a {}\n  #c a {}\n}\n```\n\n```css\na {}\n@media print {\n  #baz a {}\n}\n```\n","__filename":"user-guide/rules/no-descending-specificity.md","__url":"/user-guide/rules/no-descending-specificity/","__resourceUrl":"/user-guide/rules/no-descending-specificity/index.html","__dataUrl":"/user-guide/rules/no-descending-specificity/index.html.f99447433c5c07c0bfc59cc008dda1ca.json"}